import socket
import ssl
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# AES 키와 IV 생성
AES_KEY = os.urandom(32)  # 256-bit AES 키
IV = os.urandom(16)       # 128-bit 초기화 벡터(IV)

def encrypt_message(message: str) -> bytes:
    cipher = Cipher(algorithms.AES(AES_KEY), modes.CFB(IV), backend=default_backend())
    encryptor = cipher.encryptor()
    return IV + encryptor.update(message.encode()) + encryptor.finalize()

def decrypt_message(encrypted_message: bytes) -> str:
    iv = encrypted_message[:16]
    cipher = Cipher(algorithms.AES(AES_KEY), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encrypted_message[16:]) + decryptor.finalize()
    
    try:
        return decrypted_data.decode('utf-8')
    except UnicodeDecodeError:
        print("복호화된 데이터가 문자열이 아닙니다.")
        return decrypted_data

server_hostname = 'localhost'
server_port = 8443

# SSL 설정
context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
context.check_hostname = True
context.load_verify_locations(r"C:\\Users\\rkwls\\certs\\cert.pem")

client_socket = socket.create_connection((server_hostname, server_port))
ssl_client_socket = context.wrap_socket(client_socket, server_hostname=server_hostname)

# AES 키와 IV 전송
ssl_client_socket.sendall(AES_KEY + IV)

# 사용자 입력을 받아 메시지 전송
message = input("서버에 전송할 메시지를 입력하세요: ")
encrypted_message = encrypt_message(message)
ssl_client_socket.sendall(encrypted_message)

# 서버로부터 암호화된 응답 수신 및 복호화
encrypted_response = ssl_client_socket.recv(1024)
if len(encrypted_response) < 16:
    print("암호화된 응답이 올바르지 않습니다.")
else:
    response = decrypt_message(encrypted_response)
    print("서버에서 받은 응답:", response)

ssl_client_socket.close()
