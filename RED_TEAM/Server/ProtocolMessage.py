import os
import random
import hashlib
import json
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode


class ProtocolMessage:
    REQUEST_TYPES = {}
    DATA_TYPES = {}
    STATE = random.randint(0, 100)  # 초기 상태값

    @classmethod
    def initialize_mappings(cls):
        """요청 유형과 데이터 유형을 난수 기반으로 매핑."""
        request_types_list = ["TEXT", "EXECUTABLE", "VIDEO", "IMAGE", "ADMIN", "LOG"]
        data_types_list = ["TEXT", "BINARY", "VIDEO", "IMAGE", "JSON"]
        cls.REQUEST_TYPES = {item: os.urandom(1)[0] for item in request_types_list}
        cls.DATA_TYPES = {item: os.urandom(1)[0] for item in data_types_list}

    def __init__(self, session_id, request_type, data_type, payload):
        ProtocolMessage.initialize_mappings()
        self.session_id = session_id
        self.request_type = request_type
        self.data_type = data_type
        self.payload = payload
        self.aes_key = get_random_bytes(16)  # AES 대칭 키
        self.rsa_key = RSA.generate(2048)  # RSA 비대칭 키
        self.buffer = []  # 상태 데이터 저장소

    def dynamic_state_update(self):
        """상태(State)를 난수와 연계하여 동적으로 업데이트."""
        ProtocolMessage.STATE = (ProtocolMessage.STATE + random.randint(1, 10)) % 256

    def encrypt_payload(self, data):
        """
        AES GCM으로 페이로드 암호화.
        """
        cipher = AES.new(self.aes_key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(data)
        return cipher.nonce, ciphertext, tag

    def encrypt_aes_key(self):
        """
        RSA로 AES 대칭 키 암호화.
        """
        rsa_cipher = PKCS1_OAEP.new(self.rsa_key.publickey())
        return rsa_cipher.encrypt(self.aes_key)

    def multi_layer_encrypt(self, data):
        """
        다단계 암호화: AES 암호화 -> RSA로 키 암호화 -> 상태 기반 변환.
        """
        nonce, ciphertext, tag = self.encrypt_payload(data)
        encrypted_aes_key = self.encrypt_aes_key()

        # 상태 기반 변환
        self.dynamic_state_update()
        transformed_data = bytes([(b + ProtocolMessage.STATE) % 256 for b in ciphertext])

        return encrypted_aes_key, nonce, transformed_data, tag

    def transform_data(self, data):
        """
        데이터를 Base64로 인코딩하고 XOR 변형 후 Hex로 인코딩.
        """
        base64_encoded = b64encode(data).decode('utf-8').rstrip('=')
        xor_key = random.randint(1, 255)
        transformed = ''.join(chr((ord(c) ^ xor_key) % 256) for c in base64_encoded)
        return transformed.encode('utf-8').hex(), xor_key

    def reverse_transform_data(self, hex_data, xor_key):
        """
        Hex로 인코딩된 데이터를 복원 및 XOR 및 Base64 디코딩.
        """
        transformed = bytes.fromhex(hex_data).decode('utf-8')
        base64_encoded = ''.join(chr((ord(c) ^ xor_key) % 256) for c in transformed)
        base64_padded = base64_encoded + '=' * ((4 - len(base64_encoded) % 4) % 4)
        return b64decode(base64_padded)

    def serialize(self):
        """
        객체를 직렬화:
        - 다단계 암호화된 데이터와 가짜 데이터 결합.
        """
        encrypted_aes_key, nonce, transformed_data, tag = self.multi_layer_encrypt(self.payload)
        transformed_payload, xor_key = self.transform_data(transformed_data)

        return json.dumps({
            "encrypted_aes_key": encrypted_aes_key.hex(),
            "nonce": nonce.hex(),
            "transformed_payload": transformed_payload,
            "tag": tag.hex(),
            "xor_key": xor_key
        })

    @classmethod
    def deserialize(cls, message):
        """
        JSON 형식 메시지를 역직렬화:
        - 암호화된 데이터 복호화.
        """
        data = json.loads(message)
        encrypted_aes_key = bytes.fromhex(data["encrypted_aes_key"])
        nonce = bytes.fromhex(data["nonce"])
        transformed_payload = data["transformed_payload"]
        xor_key = data["xor_key"]
        tag = bytes.fromhex(data["tag"])

        # RSA로 AES 키 복호화
        rsa_cipher = PKCS1_OAEP.new(cls.rsa_key)
        aes_key = rsa_cipher.decrypt(encrypted_aes_key)

        # 데이터 복호화
        ciphertext = cls.reverse_transform_data(transformed_payload, xor_key)
        cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce)
        payload = cipher.decrypt_and_verify(ciphertext, tag)

        # ProtocolMessage 객체 반환
        return cls(None, None, None, payload)