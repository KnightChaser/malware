from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes


class ProtocolMessage:
    rsa_key = None
    aes_key = None

    @classmethod
    def set_rsa_key(cls):
        cls.rsa_key = RSA.generate(2048)

    @classmethod
    def get_rsa_public_key(cls):
        if cls.rsa_key is None:
            raise ValueError("RSA key has not been initialized.")
        return cls.rsa_key.publickey()

    @classmethod
    def set_rsa_public_key(cls, public_key_data):
        cls.rsa_key = RSA.import_key(public_key_data)

    @classmethod
    def generate_aes_key(cls):
        cls.aes_key = get_random_bytes(16)
        return cls.aes_key

    @classmethod
    def encrypt_aes_key(cls, aes_key):
        cipher_rsa = PKCS1_OAEP.new(cls.rsa_key.publickey())
        return cipher_rsa.encrypt(aes_key)

    @classmethod
    def decrypt_aes_key(cls, encrypted_aes_key):
        cipher_rsa = PKCS1_OAEP.new(cls.rsa_key)
        cls.aes_key = cipher_rsa.decrypt(encrypted_aes_key)

    @classmethod
    def encrypt_message(cls, message):
        if cls.aes_key is None:
            raise ValueError("AES key has not been set.")
        nonce = get_random_bytes(16)  # Nonce 생성
        cipher = AES.new(cls.aes_key, AES.MODE_GCM, nonce=nonce)
        ciphertext, tag = cipher.encrypt_and_digest(message.encode())
        return nonce + ciphertext + tag

    @classmethod
    def decrypt_message(cls, encrypted_message):
        if cls.aes_key is None:
            raise ValueError("AES key has not been set.")
        nonce = encrypted_message[:16]
        ciphertext = encrypted_message[16:-16]
        tag = encrypted_message[-16:]
        cipher = AES.new(cls.aes_key, AES.MODE_GCM, nonce=nonce)
        return cipher.decrypt_and_verify(ciphertext, tag).decode()