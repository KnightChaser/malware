import struct
import json
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode

'''
ProtocolMessage 클래스를 통해 다양한 데이터 유형을 직렬화/역직렬화 및 암호화/복호화하고,
요청 유형과 데이터 타입을 지정하여 서버와 클라이언트 간 통신이 가능하도록 프로토콜을 정의
'''

class ProtocolMessage:
    # 요청 유형과 데이터 타입 정의 (각 유형별 코드로 매핑)
    REQUEST_TYPES = {
        "TEXT": 0x01,
        "EXECUTABLE": 0x02,
        "VIDEO": 0x03,
        "IMAGE": 0x04,
        "ADMIN": 0x05,
        "LOG": 0x06
    }

    DATA_TYPES = {
        "TEXT": 0x01,
        "BINARY": 0x02,
        "VIDEO": 0x03,
        "IMAGE": 0x04,
        "JSON": 0x05
    }

    # AES 키를 저장할 클래스 변수 (공유된 AES 키)
    shared_key = None

    @classmethod
    def set_shared_key(cls, key):
        # 공유된 AES 키를 설정하는 클래스 메서드
        cls.shared_key = key

    def __init__(self, session_id, request_type, data_type, payload):
        # 메시지의 기본 정보와 데이터를 초기화
        self.session_id = session_id
        self.request_type = request_type
        self.data_type = data_type
        self.payload = payload
        self.key = ProtocolMessage.shared_key  # 공유된 AES 키 사용

    def add_padding(self, data):
        # 데이터에 랜덤 패딩을 추가
        padding_length = random.randint(8, 16)  # 패딩 길이 랜덤 설정
        padding = get_random_bytes(padding_length)
        return data + padding

    def insert_random_data(self, data):
        # 페이로드나 헤더에 임의의 데이터를 삽입
        random_data = get_random_bytes(random.randint(5, 10))  # 임의의 데이터 크기
        position = random.randint(0, len(data))  # 데이터를 삽입할 위치 랜덤 설정
        return data[:position] + random_data + data[position:]


    def encrypt_payload(self):
        # AES 암호화를 수행하여 payload를 암호화
        if self.key is None:
            raise ValueError("AES key has not been set. Please call set_shared_key() before using this method.")

        cipher = AES.new(self.key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(self.payload)
        return cipher.nonce, ciphertext, tag

    def decrypt_payload(self, nonce, ciphertext, tag):
        # AES 복호화를 수행하여 암호화된 payload를 복호화
        if self.key is None:
            raise ValueError("AES key has not been set. Please call set_shared_key() before using this method.")

        cipher = AES.new(self.key, AES.MODE_GCM, nonce=nonce)
        return cipher.decrypt_and_verify(ciphertext, tag)

    def serialize(self):
        # 암호화된 payload와 메타데이터를 직렬화하여 전송 가능한 바이트 형태로 변환
        nonce, ciphertext, tag = self.encrypt_payload()

        # 메시지 헤더를 정의하여 데이터에 추가
        header = struct.pack(
            '>B B I I 16s',
            ProtocolMessage.REQUEST_TYPES[self.request_type],  # 요청 유형
            ProtocolMessage.DATA_TYPES[self.data_type],        # 데이터 유형
            len(ciphertext),                                   # 암호화된 데이터 길이
            self.session_id,                                   # 세션 ID
            nonce                                              # Nonce
        )

        # 헤더 + 암호화된 데이터 + 태그를 결합하여 최종 메시지 생성
        message = header + ciphertext + tag
        return message

    @classmethod
    def deserialize(cls, message):
        # 수신된 메시지를 역직렬화하여 복원
        request_type, data_type, data_length, session_id, nonce = struct.unpack('>B B I I 16s', message[:26])
        ciphertext = message[26:26 + data_length]
        tag = message[26 + data_length:]

        # 새로운 ProtocolMessage 객체 생성 및 복호화
        protocol_message = cls(session_id, request_type, data_type, b"")
        protocol_message.key = ProtocolMessage.shared_key
        payload = protocol_message.decrypt_payload(nonce, ciphertext, tag)
        protocol_message.payload = payload
        return protocol_message

    def to_json(self):
        # 메시지를 JSON 형식으로 직렬화하여 문자열로 변환
        return json.dumps({
            "session_id": self.session_id,
            "request_type": self.request_type,
            "data_type": self.data_type,
            "payload": b64encode(self.payload).decode('utf-8')
        })

    @classmethod
    def from_json(cls, json_str):
        # JSON 문자열에서 메시지 객체를 생성
        data = json.loads(json_str)
        payload = b64decode(data["payload"])
        return cls(
            session_id=data["session_id"],
            request_type=data["request_type"],
            data_type=data["data_type"],
            payload=payload
        )

