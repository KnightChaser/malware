import socket
import ssl
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# 서버 설정
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 8443))
server_socket.listen(5)

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain(certfile=r"C:\\Users\\rkwls\\certs\\cert.pem", keyfile=r"C:\\Users\\rkwls\\certs\\privKey.pem")

def decrypt_message(encrypted_message: bytes, aes_key: bytes, iv: bytes) -> str:
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encrypted_message) + decryptor.finalize()
    return decrypted_data.decode('utf-8')

print("SSL 서버가 실행 중입니다...")

while True:
    client_socket, addr = server_socket.accept()
    ssl_client_socket = context.wrap_socket(client_socket, server_side=True)
    print(f"클라이언트 연결됨: {addr}")

    # AES 키와 IV 수신
    aes_key = ssl_client_socket.recv(32)
    iv = ssl_client_socket.recv(16)

    # 암호화된 메시지 수신 및 복호화
    encrypted_data = ssl_client_socket.recv(1024)
    data = decrypt_message(encrypted_data, aes_key, iv)
    print("받은 데이터:", data)

    # 클라이언트로 암호화된 응답 전송
    response = "서버에서 응답합니다."
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    encrypted_response = encryptor.update(response.encode()) + encryptor.finalize()
    ssl_client_socket.sendall(encrypted_response)

    ssl_client_socket.close()
