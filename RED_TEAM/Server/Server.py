import socket
import ssl
import mysql.connector
import threading
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# AES 암호화 및 복호화 함수
def encrypt_message(message: str, aes_key: bytes, iv: bytes) -> bytes:
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return iv + encryptor.update(message.encode()) + encryptor.finalize()

def decrypt_message(encrypted_message: bytes, aes_key: bytes) -> str:
    iv = encrypted_message[:16]
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encrypted_message[16:]) + decryptor.finalize()
    
    try:
        return decrypted_data.decode('utf-8')
    except UnicodeDecodeError:
        print("복호화된 데이터가 문자열이 아닙니다.")
        return decrypted_data

# MariaDB 연결 설정
def connect_to_db():
    try:
        connection = mysql.connector.connect(
            host="localhost",
            user="brainoverflow",
            password="1234",
            database="test",
            port=3306,
            charset="utf8mb4",
            collation="utf8mb4_general_ci"
        )
        if connection.is_connected():
            print("MySQL database connection successful")
            return connection
    except mysql.connector.Error as e:
        print(f"Error while connecting to MySQL: {e}")
        return None

# 각 클라이언트 연결을 처리하는 함수
def handle_client(ssl_client_socket, addr):
    print(f"클라이언트 연결됨: {addr}")

    # AES 키와 IV 수신
    aes_key_iv = ssl_client_socket.recv(48)
    AES_KEY = aes_key_iv[:32]  # 첫 32 바이트는 AES 키
    IV = aes_key_iv[32:]       # 다음 16 바이트는 IV
    print("AES 키와 IV 수신 완료")

    try:
        while True:
            # 암호화된 데이터 수신 및 복호화
            encrypted_data = ssl_client_socket.recv(1024)
            if not encrypted_data:
                print("클라이언트 연결이 종료되었습니다.")
                break

            data = decrypt_message(encrypted_data, AES_KEY)
            print("받은 데이터:", data)

            # MariaDB에 데이터 삽입
            connection = connect_to_db()
            if connection:
                cursor = connection.cursor()
                
                # 메시지를 저장할 테이블 이름과 컬럼 이름 확인 (messages 테이블과 message 컬럼)
                try:
                    cursor.execute("INSERT INTO messages (message) VALUES (%s)", (data,))
                    connection.commit()
                    print("데이터가 데이터베이스에 성공적으로 삽입되었습니다.")
                except mysql.connector.Error as e:
                    print(f"데이터베이스에 데이터를 삽입하는 중 오류 발생: {e}")
                
                cursor.close()
                connection.close()

            # 응답 전송
            response = "Response from Server."
            encrypted_response = encrypt_message(response, AES_KEY, IV)
            ssl_client_socket.sendall(encrypted_response)

    except Exception as e:
        print(f"클라이언트 처리 중 오류 발생: {e}")
    finally:
        ssl_client_socket.close()
        print("클라이언트와의 연결이 종료되었습니다.")

# 서버 소켓 설정 및 SSL 컨텍스트 생성
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 8443))
server_socket.listen(5)

context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain(certfile=r"C:\\Users\\woojin\\Desktop\\Malware\\RED_TEAM\\Server\\cert.pem", 
                        keyfile=r"C:\\Users\\woojin\\Desktop\\Malware\\RED_TEAM\\Server\\privKey.pem")

print("SSL 서버가 실행 중입니다...")

# 다수의 클라이언트 연결 처리
while True:
    client_socket, addr = server_socket.accept()
    ssl_client_socket = context.wrap_socket(client_socket, server_side=True)
    
    # 새로운 스레드를 시작하여 각 클라이언트를 처리
    client_thread = threading.Thread(target=handle_client, args=(ssl_client_socket, addr))
    client_thread.start()
