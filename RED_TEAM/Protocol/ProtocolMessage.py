import os
import struct
import random
import hashlib
import json
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode


class ProtocolMessage:
    REQUEST_TYPES = {}
    DATA_TYPES = {}
    STATE = random.randint(0, 100)  # 상태 기반 설계

    @classmethod
    def initialize_mappings(cls):
        """
        요청 유형과 데이터 유형을 난수 기반으로 동적으로 매핑.
        """
        request_types_list = ["TEXT", "EXECUTABLE", "VIDEO", "IMAGE", "ADMIN", "LOG"]
        data_types_list = ["TEXT", "BINARY", "VIDEO", "IMAGE", "JSON"]
        cls.REQUEST_TYPES = {item: os.urandom(1)[0] for item in request_types_list}
        cls.DATA_TYPES = {item: os.urandom(1)[0] for item in data_types_list}

    def __init__(self, session_id, request_type, data_type, payload):
        ProtocolMessage.initialize_mappings()

        self.session_id = session_id
        self.request_type = request_type
        self.data_type = data_type
        self.payload = payload
        self.aes_key = get_random_bytes(16)  # AES 대칭 키 생성
        self.rsa_key = RSA.generate(2048)  # RSA 비대칭 키 생성
        self.buffer = []  # 상태 기반 데이터 저장

    def dynamic_state_update(self):
        """
        상태(State)를 난수와 연계하여 동적으로 업데이트.
        """
        ProtocolMessage.STATE = (ProtocolMessage.STATE + random.randint(1, 10)) % 256

    def multi_layer_encrypt(self, data):
        """
        다단계 암호화 수행:
        - AES GCM 암호화: 데이터 무결성 및 기밀성 보장.
        - RSA 공개 키로 AES 대칭 키 암호화.
        - 상태(State) 기반 데이터 변환.
        """
        # AES 암호화
        cipher = AES.new(self.aes_key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(data)

        # RSA 암호화로 AES 키 암호화
        rsa_cipher = PKCS1_OAEP.new(self.rsa_key.publickey())
        encrypted_aes_key = rsa_cipher.encrypt(self.aes_key)

        # 상태 기반 변환
        self.dynamic_state_update()
        transformed_data = bytes([(b + ProtocolMessage.STATE) % 256 for b in ciphertext])
        return encrypted_aes_key, transformed_data, tag

    def transform_data(self, data):
        """
        데이터를 Base64로 인코딩하고, XOR 변형한 뒤 Hex로 인코딩.
        """
        # Base64 인코딩
        base64_encoded = b64encode(data).decode('utf-8').rstrip('=')

        # XOR 변형
        xor_key = random.randint(1, 255)
        transformed = ''.join(chr((ord(c) ^ xor_key) % 256) for c in base64_encoded)

        # Hex로 변환
        hex_encoded = transformed.encode('utf-8').hex()
        return hex_encoded, xor_key

    def reverse_transform_data(self, hex_data, xor_key):
        """
        Hex로 인코딩된 데이터를 복원하고 XOR 및 Base64 디코딩.
        """
        # Hex 디코딩
        transformed = bytes.fromhex(hex_data).decode('utf-8')

        # XOR 복원
        base64_encoded = ''.join(chr((ord(c) ^ xor_key) % 256) for c in transformed)

        # Base64 디코딩
        base64_padded = base64_encoded + '=' * ((4 - len(base64_encoded) % 4) % 4)
        return b64decode(base64_padded)

    def serialize(self):
        """
        직렬화 수행:
        - 페이로드와 헤더를 각각 암호화.
        - 다단계 암호화된 데이터와 가짜 데이터를 결합.
        """
        # 페이로드 암호화
        encrypted_aes_key, ciphertext, tag_payload = self.multi_layer_encrypt(self.payload)

        # 헤더 생성 및 암호화
        dynamic_header = self.generate_dynamic_header(ciphertext)
        nonce_header, encrypted_header, tag_header = self.encrypt_header(dynamic_header)

        # 데이터 변형
        transformed_payload, xor_key = self.transform_data(ciphertext)

        # 최종 메시지 구성
        message = {
            "encrypted_aes_key": encrypted_aes_key.hex(),
            "nonce_header": nonce_header.hex(),
            "encrypted_header": encrypted_header.hex(),
            "tag_header": tag_header.hex(),
            "payload": transformed_payload,
            "tag_payload": tag_payload.hex(),
            "xor_key": xor_key,
        }
        return json.dumps(message)

    @classmethod
    def deserialize(cls, message):
        """
        역직렬화 수행:
        - 암호화된 헤더 및 페이로드를 복호화.
        - 난독화된 데이터의 구조를 복원.
        """
        data = json.loads(message)

        # RSA를 통해 AES 키 복호화
        encrypted_aes_key = bytes.fromhex(data["encrypted_aes_key"])
        rsa_cipher = PKCS1_OAEP.new(cls.rsa_key)
        aes_key = rsa_cipher.decrypt(encrypted_aes_key)

        # 헤더 복호화
        nonce_header = bytes.fromhex(data["nonce_header"])
        encrypted_header = bytes.fromhex(data["encrypted_header"])
        tag_header = bytes.fromhex(data["tag_header"])
        cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce_header)
        header = cipher.decrypt_and_verify(encrypted_header, tag_header)

        # 페이로드 복호화
        transformed_payload = data["payload"]
        xor_key = data["xor_key"]
        ciphertext = cls.reverse_transform_data(transformed_payload, xor_key)
        tag_payload = bytes.fromhex(data["tag_payload"])
        cipher = AES.new(aes_key, AES.MODE_GCM)
        payload = cipher.decrypt_and_verify(ciphertext, tag_payload)

        # 새로운 ProtocolMessage 객체 생성
        protocol_message = cls(None, None, None, payload)
        protocol_message.aes_key = aes_key
        return protocol_message
