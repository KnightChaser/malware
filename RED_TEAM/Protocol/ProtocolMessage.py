import os
import struct
import random
import time
import hashlib
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode


class ProtocolMessage:
    REQUEST_TYPES = {}
    DATA_TYPES = {}
    STATE = random.randint(0, 100)  # 상태 기반 설계

    @classmethod
    def initialize_mappings(cls):
        """
        요청 유형과 데이터 유형을 난수 기반으로 동적으로 매핑.
        - 난수를 사용하여 요청 및 데이터 유형의 매핑을 동적으로 생성.
        """
        request_types_list = ["TEXT", "EXECUTABLE", "VIDEO", "IMAGE", "ADMIN", "LOG"]
        data_types_list = ["TEXT", "BINARY", "VIDEO", "IMAGE", "JSON"]
        cls.REQUEST_TYPES = {item: os.urandom(1)[0] for item in request_types_list}
        cls.DATA_TYPES = {item: os.urandom(1)[0] for item in data_types_list}

    def __init__(self, session_id, request_type, data_type, payload):
        ProtocolMessage.initialize_mappings()

        self.session_id = session_id
        self.request_type = request_type
        self.data_type = data_type
        self.payload = payload
        self.aes_key = get_random_bytes(16)  # AES 대칭 키 생성
        self.rsa_key = RSA.generate(2048)  # RSA 비대칭 키 생성
        self.buffer = []  # 상태 기반 데이터 저장

    def dynamic_state_update(self):
        """
        상태(State)를 난수와 연계하여 동적으로 업데이트.
        """
        ProtocolMessage.STATE = (ProtocolMessage.STATE + random.randint(1, 10)) % 256

    def multi_layer_encrypt(self, data):
        """
        다단계 암호화 수행:
        - AES GCM 암호화: 데이터 무결성 및 기밀성 보장.
        - RSA 공개 키로 AES 대칭 키 암호화.
        - 상태(State) 기반 데이터 변환.
        """
        # AES 암호화
        cipher = AES.new(self.aes_key, AES.MODE_GCM)
        ciphertext, tag = cipher.encrypt_and_digest(data)

        # RSA 암호화로 AES 키 암호화
        rsa_cipher = PKCS1_OAEP.new(self.rsa_key.publickey())
        encrypted_aes_key = rsa_cipher.encrypt(self.aes_key)

        # 상태 기반 변환
        self.dynamic_state_update()
        transformed_data = bytes([(b + ProtocolMessage.STATE) % 256 for b in ciphertext])
        return encrypted_aes_key, transformed_data, tag

    def generate_dynamic_header(self, ciphertext):
        """
        동적 헤더 생성:
        - 요청 유형 및 데이터 유형을 난수 기반 값으로 포함.
        - 데이터 크기, 세션 ID, 랜덤 Nonce를 포함.
        - 가짜 데이터 삽입으로 헤더 구조를 불규칙화.
        """
        dynamic_nonce = get_random_bytes(12)  # 랜덤 Nonce 생성
        header = struct.pack(
            '>B B I Q',
            ProtocolMessage.REQUEST_TYPES[self.request_type],
            ProtocolMessage.DATA_TYPES[self.data_type],
            len(ciphertext),
            self.session_id
        )

        # 가짜 데이터 삽입
        fake_data = os.urandom(random.randint(8, 16))
        insert_position = random.randint(0, len(header))
        header_with_fake_data = header[:insert_position] + fake_data + header[insert_position:]

        return dynamic_nonce + header_with_fake_data

    def encrypt_header(self, header):
        """
        AES GCM 모드를 사용하여 헤더 암호화:
        - 동적 키를 사용하여 헤더 암호화.
        - 헤더 변조 방지 및 무결성 보장.
        """
        cipher = AES.new(self.aes_key, AES.MODE_GCM)
        encrypted_header, tag = cipher.encrypt_and_digest(header)
        return cipher.nonce, encrypted_header, tag

    def serialize(self):
        """
        직렬화 수행:
        - 페이로드와 헤더를 각각 암호화.
        - 다단계 암호화된 데이터와 가짜 데이터를 결합.
        """
        # 페이로드 암호화
        encrypted_aes_key, ciphertext, tag_payload = self.multi_layer_encrypt(self.payload)

        # 헤더 생성 및 암호화
        dynamic_header = self.generate_dynamic_header(ciphertext)
        nonce_header, encrypted_header, tag_header = self.encrypt_header(dynamic_header)

        # 패딩 및 가짜 데이터 삽입
        fake_data_packet = os.urandom(random.randint(16, 32))

        # 최종 메시지 구성
        message = (
            encrypted_aes_key +
            nonce_header + encrypted_header + tag_header +
            ciphertext + tag_payload +
            fake_data_packet
        )
        return message

    @classmethod
    def deserialize(cls, message):
        """
        역직렬화 수행:
        - 암호화된 헤더 및 페이로드를 복호화.
        - 난독화된 데이터의 구조를 복원.
        """
        # RSA를 통해 AES 키 복호화
        encrypted_aes_key = message[:256]
        rsa_cipher = PKCS1_OAEP.new(cls.rsa_key)
        aes_key = rsa_cipher.decrypt(encrypted_aes_key)

        # 헤더 복호화
        nonce_header = message[256:268]
        encrypted_header = message[268:300]
        tag_header = message[300:316]
        cipher = AES.new(aes_key, AES.MODE_GCM, nonce=nonce_header)
        header = cipher.decrypt_and_verify(encrypted_header, tag_header)

        # 헤더 분석 및 가짜 데이터 제거
        real_header_size = struct.calcsize('>B B I Q')
        real_header = header[:real_header_size]
        _, _, data_length, session_id = struct.unpack('>B B I Q', real_header)

        # 페이로드 복호화
        ciphertext_start = 316
        ciphertext_end = ciphertext_start + data_length
        ciphertext = message[ciphertext_start:ciphertext_end]
        tag_payload = message[ciphertext_end:ciphertext_end + 16]
        cipher = AES.new(aes_key, AES.MODE_GCM)
        payload = cipher.decrypt_and_verify(ciphertext, tag_payload)

        # 새로운 ProtocolMessage 객체 생성
        protocol_message = cls(session_id, None, None, payload)
        protocol_message.aes_key = aes_key
        return protocol_message

    def to_json(self):
        """
        메시지를 JSON 형식으로 직렬화:
        - 페이로드를 Base64로 인코딩.
        """
        return json.dumps({
            "session_id": self.session_id,
            "request_type": self.request_type,
            "data_type": self.data_type,
            "payload": b64encode(self.payload).decode('utf-8')
        })

    @classmethod
    def from_json(cls, json_str):
        """
        JSON 형식 메시지를 ProtocolMessage 객체로 복원.
        """
        data = json.loads(json_str)
        payload = b64decode(data["payload"])
        return cls(
            session_id=data["session_id"],
            request_type=data["request_type"],
            data_type=data["data_type"],
            payload=payload
        )


        )

